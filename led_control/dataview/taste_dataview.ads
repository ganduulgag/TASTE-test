-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
USE adaasn1rtl;
use type adaasn1rtl.OctetBuffer;
use type adaasn1rtl.BitArray;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;
--# inherit ;


PACKAGE TASTE_Dataview with SPARK_Mode
IS


SUBTYPE asn1SccTASTE_Boolean is adaasn1rtl.Asn1Boolean;


function asn1SccTASTE_Boolean_Equal(val1, val2: in asn1SccTASTE_Boolean) return Boolean;

function asn1SccTASTE_Boolean_Init return asn1SccTASTE_Boolean;

ERR_TASTE_BOOLEAN:CONSTANT INTEGER := 36; -- 
FUNCTION asn1SccTASTE_Boolean_IsConstraintValid(val : in asn1SccTASTE_Boolean) return adaasn1rtl.ASN1_RESULT;

ERR_UPER_ENCODE_TASTE_BOOLEAN:CONSTANT INTEGER := 37; 
asn1SccTASTE_Boolean_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := 1;
asn1SccTASTE_Boolean_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := 1;

SUBTYPE asn1SccTASTE_Boolean_uPER_bit_array_range is Natural range 1..asn1SccTASTE_Boolean_REQUIRED_BITS_FOR_ENCODING;
SUBTYPE asn1SccTASTE_Boolean_uPER_bit_array is adaasn1rtl.BitArray(asn1SccTASTE_Boolean_uPER_bit_array_range);

TYPE asn1SccTASTE_Boolean_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : asn1SccTASTE_Boolean_uPER_bit_array;
end RECORD;

procedure asn1SccTASTE_Boolean_Encode(val:in asn1SccTASTE_Boolean; Stream : OUT asn1SccTASTE_Boolean_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccTASTE_Boolean_Encode_aux(val:in asn1SccTASTE_Boolean; S : in out adaasn1rtl.BitArray; K : in out Natural; result : OUT adaasn1rtl.ASN1_RESULT)
;

ERR_UPER_DECODE_TASTE_BOOLEAN:CONSTANT INTEGER := 38; 
procedure asn1SccTASTE_Boolean_Decode(val: out asn1SccTASTE_Boolean; Stream : IN asn1SccTASTE_Boolean_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccTASTE_Boolean_Decode_aux(val: out asn1SccTASTE_Boolean; S : in adaasn1rtl.BitArray; K : in out adaasn1rtl.DECODE_PARAMS; result : OUT adaasn1rtl.ASN1_RESULT)
;
SUBTYPE asn1SccMyInteger is adaasn1rtl.Asn1UInt range 0 .. 255;


function asn1SccMyInteger_Equal(val1, val2: in asn1SccMyInteger) return Boolean;

function asn1SccMyInteger_Init return asn1SccMyInteger;

ERR_MYINTEGER:CONSTANT INTEGER := 43; -- 
FUNCTION asn1SccMyInteger_IsConstraintValid(val : in asn1SccMyInteger) return adaasn1rtl.ASN1_RESULT;

ERR_UPER_ENCODE_MYINTEGER:CONSTANT INTEGER := 44; 
asn1SccMyInteger_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := 1;
asn1SccMyInteger_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := 8;

SUBTYPE asn1SccMyInteger_uPER_bit_array_range is Natural range 1..asn1SccMyInteger_REQUIRED_BITS_FOR_ENCODING;
SUBTYPE asn1SccMyInteger_uPER_bit_array is adaasn1rtl.BitArray(asn1SccMyInteger_uPER_bit_array_range);

TYPE asn1SccMyInteger_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : asn1SccMyInteger_uPER_bit_array;
end RECORD;

procedure asn1SccMyInteger_Encode(val:in asn1SccMyInteger; Stream : OUT asn1SccMyInteger_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccMyInteger_Encode_aux(val:in asn1SccMyInteger; S : in out adaasn1rtl.BitArray; K : in out Natural; result : OUT adaasn1rtl.ASN1_RESULT)
;

ERR_UPER_DECODE_MYINTEGER:CONSTANT INTEGER := 45; 
procedure asn1SccMyInteger_Decode(val: out asn1SccMyInteger; Stream : IN asn1SccMyInteger_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccMyInteger_Decode_aux(val: out asn1SccMyInteger; S : in adaasn1rtl.BitArray; K : in out adaasn1rtl.DECODE_PARAMS; result : OUT adaasn1rtl.ASN1_RESULT)
;
SUBTYPE asn1SccT_Uint16 is adaasn1rtl.Asn1UInt range 0 .. 65535;


function asn1SccT_Uint16_Equal(val1, val2: in asn1SccT_Uint16) return Boolean;

function asn1SccT_Uint16_Init return asn1SccT_Uint16;

ERR_T_UINT16:CONSTANT INTEGER := 50; -- 
FUNCTION asn1SccT_Uint16_IsConstraintValid(val : in asn1SccT_Uint16) return adaasn1rtl.ASN1_RESULT;

ERR_UPER_ENCODE_T_UINT16:CONSTANT INTEGER := 51; 
asn1SccT_Uint16_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := 2;
asn1SccT_Uint16_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := 16;

SUBTYPE asn1SccT_Uint16_uPER_bit_array_range is Natural range 1..asn1SccT_Uint16_REQUIRED_BITS_FOR_ENCODING;
SUBTYPE asn1SccT_Uint16_uPER_bit_array is adaasn1rtl.BitArray(asn1SccT_Uint16_uPER_bit_array_range);

TYPE asn1SccT_Uint16_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : asn1SccT_Uint16_uPER_bit_array;
end RECORD;

procedure asn1SccT_Uint16_Encode(val:in asn1SccT_Uint16; Stream : OUT asn1SccT_Uint16_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_Uint16_Encode_aux(val:in asn1SccT_Uint16; S : in out adaasn1rtl.BitArray; K : in out Natural; result : OUT adaasn1rtl.ASN1_RESULT)
;

ERR_UPER_DECODE_T_UINT16:CONSTANT INTEGER := 52; 
procedure asn1SccT_Uint16_Decode(val: out asn1SccT_Uint16; Stream : IN asn1SccT_Uint16_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_Uint16_Decode_aux(val: out asn1SccT_Uint16; S : in adaasn1rtl.BitArray; K : in out adaasn1rtl.DECODE_PARAMS; result : OUT adaasn1rtl.ASN1_RESULT)
;

 

private
   --# hide TASTE_Dataview;


END TASTE_Dataview;