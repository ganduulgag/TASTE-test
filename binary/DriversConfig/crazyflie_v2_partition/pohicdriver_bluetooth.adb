-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY POHICDRIVER_BLUETOOTH with SPARK_Mode IS




function Datarate_T_Equal(val1, val2: in Datarate_T)
    return Boolean 
is
begin
	return val1 = val2;

end Datarate_T_Equal;

function Datarate_T_Init return Datarate_T
is
    val: Datarate_T;
begin
    val := d250K;
    return val;
end Datarate_T_Init;

FUNCTION Datarate_T_IsConstraintValid(val : in Datarate_T) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val = d250K)) OR ((val = d1M)))) OR ((val = d2M))), ErrorCode => ERR_DATARATE_T);
    RETURN ret;
END Datarate_T_IsConstraintValid;



function Address_T_Equal(val1, val2: in Address_T)
    return Boolean 
is
begin
	return val1.Data = val2.Data;

end Address_T_Equal;

function Address_T_Init return Address_T
is
    val: Address_T;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 5 loop
        pragma Loop_Invariant (i1 >=1 and i1<=5);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;

    return val;
end Address_T_Init;



function Bluetooth_Conf_T_channel_Equal(val1, val2: in Bluetooth_Conf_T_channel)
    return Boolean 
is
begin
	return val1 = val2;

end Bluetooth_Conf_T_channel_Equal;

function Bluetooth_Conf_T_Equal(val1, val2: in Bluetooth_Conf_T)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Bluetooth_Conf_T_channel_Equal(val1.channel, val2.channel);

    if ret then
        ret := val1.Exist.datarate = val2.Exist.datarate;
        if ret and then val1.Exist.datarate = 1 then
            ret := (val1.datarate = val2.datarate);
        end if;

        if ret then
            ret := val1.Exist.address = val2.Exist.address;
            if ret and then val1.Exist.address = 1 then
                ret := Address_T_Equal(val1.address, val2.address);
            end if;

        end if;
    end if;
	return ret;

end Bluetooth_Conf_T_Equal;

function Bluetooth_Conf_T_channel_Init return Bluetooth_Conf_T_channel
is
    val: Bluetooth_Conf_T_channel;
begin
    val := 0;
    return val;
end Bluetooth_Conf_T_channel_Init;
function Bluetooth_Conf_T_Init return Bluetooth_Conf_T
is
    val: Bluetooth_Conf_T;
begin

    --set channel 
    val.channel := Bluetooth_Conf_T_channel_Init;
    --set datarate 
    val.exist.datarate := 1;
    val.datarate := Datarate_T_Init;
    --set address 
    val.exist.address := 1;
    val.address := Address_T_Init;
    return val;
end Bluetooth_Conf_T_Init;

FUNCTION Bluetooth_Conf_T_IsConstraintValid(val : in Bluetooth_Conf_T) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.channel <= 125), ErrorCode => ERR_BLUETOOTH_CONF_T_CHANNEL);
    if ret.Success then
        if val.Exist.datarate = 1 then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.datarate = d250K)) OR ((val.datarate = d1M)))) OR ((val.datarate = d2M))), ErrorCode => ERR_BLUETOOTH_CONF_T_DATARATE);
        end if;
    end if;

    RETURN ret;
END Bluetooth_Conf_T_IsConstraintValid;


 

END POHICDRIVER_BLUETOOTH;